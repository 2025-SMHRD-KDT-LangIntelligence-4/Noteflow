<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<link rel="stylesheet" th:href="@{/css/header.css}" />
<link rel="stylesheet" th:href="@{/css/notionCreate.css}"/>
<link rel="stylesheet" th:href="@{/css/ckEditor.css}"/>
<link rel="stylesheet" href="https://cdn.ckeditor.com/ckeditor5/47.0.0/ckeditor5.css" crossorigin>
<link rel="stylesheet" th:href="@{/css/footer.css}" />

</head>
<body>
<div th:replace="fragments/header :: siteHeader"></div>	

<div class="full-container">
  <div class="slide-location-container">
  	<div class="slide-container">
		      <button class="arrow left">‹</button>
		  <div class="slider-wrapper">
			  <div class="button-container" id="buttonContainer"></div>
		  </div>
		      <button class="arrow right">›</button>
  	</div>
  </div>

  <div class="text-container">
    <div class="input-location-container">
      <form class="input-container">
        <input class="title" placeholder="제목을 입력하세요"/>
        <textarea class="notion-text" placeholder="작성공간입니다."></textarea>
        <button class="submit-button">작성</button>
      </form>
    </div>

    <div class="result-location-container">
      <div class="result-container">
        <div class="result-title">결과물 제목</div>
			<div class="main-container">
				<div class="editor-container editor-container_classic-editor" id="editor-container">
					<div class="editor-container__editor"><div id="editor"></div></div>
				</div>
			</div>
        
        <button class="save-button">저장</button>
      </div>
    </div>
  </div>
</div>
<script src="https://cdn.ckeditor.com/ckeditor5/47.0.0/ckeditor5.umd.js" crossorigin></script>
<script src="https://cdn.ckeditor.com/ckeditor5/47.0.0/translations/ko.umd.js" crossorigin></script>
<script th:src="@{/js/ckEditor.js}"></script>
  	<script>
	    const versionNames = [
	      "심플버전", "문제중심버전", "학습 전부 기록버전", "스토리텔링버전",
	      "액션아이템버전", "키워드버전", "인사이트중심버전", "코드로그버전",
	      "비주얼요약버전", "감정일기버전", "짧은 Q&A버전", "성과지향버전",
	      "멘토링버전", "리서치논문버전", "미래투영버전", "포트폴리오버전"
	    ];
	
	    const container = document.getElementById("buttonContainer");
	    versionNames.forEach(name => {
	      const btn = document.createElement("button");
	      btn.textContent = name;
	      btn.className = "slide-btn";
	      container.appendChild(btn);
	    });
	    const slideContainer = document.querySelector(".slide-container");
	
	    slideContainer.addEventListener("wheel", (e) => {
	      e.preventDefault(); // 기본 수직 스크롤 막기
	      slideContainer.scrollBy({
	        left: e.deltaY, // 마우스 휠 수직 이동을 좌우 스크롤로 변환
	        behavior: "smooth"
	      });
	    });
	    // 좌우 이동 버튼
	    const wrapper = document.querySelector('.slider-wrapper');
	    const leftBtn = document.querySelector('.arrow.left');
	    const rightBtn = document.querySelector('.arrow.right');
	    let scrollPosition = 0;
	    wrapper.addEventListener("wheel", (e) => {
	    	  e.preventDefault();
	    	  wrapper.scrollBy({ left: e.deltaY*3, behavior: "smooth" });
	    	});
	    const moveSlide = (direction) => {
	      const slideWidth = 1000; // 한 번에 이동할 픽셀
	      scrollPosition += direction === 'right' ? -slideWidth : slideWidth;
	      const maxScroll = -(container.scrollWidth - wrapper.offsetWidth);
	      scrollPosition = Math.min(0, Math.max(scrollPosition, maxScroll));
	      container.style.transform = `translateX(${scrollPosition}px)`;
	    };
	
	    leftBtn.addEventListener('click', () => moveSlide('left'));
	    rightBtn.addEventListener('click', () => moveSlide('right'));
	
	    // 드래그 슬라이드 기능
	    let isDown = false;
	    let startX;
	    let scrollStart;
	
	    wrapper.addEventListener('mousedown', e => {
	      isDown = true;
	      startX = e.pageX;
	      scrollStart = scrollPosition;
	    });
	    wrapper.addEventListener('mouseleave', () => isDown = false);
	    wrapper.addEventListener('mouseup', () => isDown = false);
	    wrapper.addEventListener('mousemove', e => {
	      if (!isDown) return;
	      const walk = e.pageX - startX;
	      scrollPosition = scrollStart + walk;
	      const maxScroll = -(container.scrollWidth - wrapper.offsetWidth);
	      scrollPosition = Math.min(0, Math.max(scrollPosition, maxScroll));
	      container.style.transform = `translateX(${scrollPosition}px)`;
	    });
	    
	    // 슬라이드 끝까지 도달하면 버튼을 추가해서 무한루프 시킬거임
	    const originalButtons = Array.from(container.children);
		for (let i = 0; i < 3; i++) { // 3번 반복
		  originalButtons.forEach(btn => container.appendChild(btn.cloneNode(true)));
		}
		const btn = document.createElement("button");
		const originalSetWidth = originalButtons.reduce((acc, btn) => acc + btn.offsetWidth + 10, 0); 
		const slider = document.querySelector('.slide-container');
		const track = document.querySelector('.slider-wrapper');
	    let scrollSpeed = 0.5; // 픽셀 나누기 프레임 단위
	    let isPaused = false; // 호버를 하기전에는 계속 동작시킬것임
		
	    // animate함수를 통해 슬라이드를 자동으로 부드럽게 동작시킴
	    function animate() {
	      if (!isPaused) {
	    	  track.scrollLeft += scrollSpeed;
	        // 끝에 도달하면 처음으로 돌아가기
	        if (track.scrollLeft >= originalSetWidth) { 
	            //계산된 originalSetWidth 길이에 따라 무한루프 실행
	            track.scrollLeft = 0;
	        }
	      }
	      requestAnimationFrame(animate);
	    }
	
	    slider.addEventListener('mouseenter', () => isPaused = true);
	    slider.addEventListener('mouseleave', () => isPaused = false);
	
	    animate();
	</script>
	<div th:replace="fragments/footer :: siteFooter"></div>
</body>
</html>
