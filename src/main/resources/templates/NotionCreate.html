<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<link rel="stylesheet" th:href="@{/css/header.css}" />
<link rel="stylesheet" th:href="@{/css/notionCreate.css}"/>
</head>
<body>
<div th:replace="fragments/header :: siteHeader"></div>	

<div class="full-container">
  <div class="slide-location-container">
  	<div class="slide-container">
		      <button class="arrow left">‹</button>
		  <div class="slider-wrapper">
			  <div class="button-container" id="buttonContainer"></div>
		  </div>
		      <button class="arrow right">›</button>
  	</div>
  </div>

  <div class="text-container">
    <div class="input-location-container">
      <form class="input-container">
        <input class="title" placeholder="제목을 입력하세요"/>
        <textarea class="notion-text" placeholder="작성공간입니다."></textarea>
        <button class="submit-button">작성</button>
      </form>
    </div>

    <div class="result-location-container">
      <div class="result-container">
        <div class="result-title">결과물 제목</div>
        <div class="result-content">결과물 예시</div>
        <div class="margin"></div>
      </div>
    </div>
  </div>
</div>

 
  <script>
    const versionNames = [
      "심플버전", "문제중심버전", "학습 전부 기록버전", "스토리텔링버전",
      "액션아이템버전", "키워드버전", "인사이트중심버전", "코드로그버전",
      "비주얼요약버전", "감정일기버전", "짧은 Q&A버전", "성과지향버전",
      "멘토링버전", "리서치논문버전", "미래투영버전", "포트폴리오버전"
    ];

    const container = document.getElementById("buttonContainer");
    versionNames.forEach(name => {
      const btn = document.createElement("button");
      btn.textContent = name;
      btn.className = "slide-btn";
      container.appendChild(btn);
    });
    const slideContainer = document.querySelector(".slide-container");

    slideContainer.addEventListener("wheel", (e) => {
      e.preventDefault(); // 기본 수직 스크롤 막기
      slideContainer.scrollBy({
        left: e.deltaY, // 마우스 휠 수직 이동을 좌우 스크롤로 변환
        behavior: "smooth"
      });
    });
    // 좌우 이동 버튼
    const wrapper = document.querySelector('.slider-wrapper');
    const leftBtn = document.querySelector('.arrow.left');
    const rightBtn = document.querySelector('.arrow.right');
    let scrollPosition = 0;
    wrapper.addEventListener("wheel", (e) => {
    	  e.preventDefault();
    	  wrapper.scrollBy({ left: e.deltaY*3, behavior: "smooth" });
    	});
    const moveSlide = (direction) => {
      const slideWidth = 1000; // 한 번에 이동할 픽셀
      scrollPosition += direction === 'right' ? -slideWidth : slideWidth;
      const maxScroll = -(container.scrollWidth - wrapper.offsetWidth);
      scrollPosition = Math.min(0, Math.max(scrollPosition, maxScroll));
      container.style.transform = `translateX(${scrollPosition}px)`;
    };

    leftBtn.addEventListener('click', () => moveSlide('left'));
    rightBtn.addEventListener('click', () => moveSlide('right'));

    // 드래그 슬라이드 기능
    let isDown = false;
    let startX;
    let scrollStart;

    wrapper.addEventListener('mousedown', e => {
      isDown = true;
      startX = e.pageX;
      scrollStart = scrollPosition;
    });
    wrapper.addEventListener('mouseleave', () => isDown = false);
    wrapper.addEventListener('mouseup', () => isDown = false);
    wrapper.addEventListener('mousemove', e => {
      if (!isDown) return;
      const walk = e.pageX - startX;
      scrollPosition = scrollStart + walk;
      const maxScroll = -(container.scrollWidth - wrapper.offsetWidth);
      scrollPosition = Math.min(0, Math.max(scrollPosition, maxScroll));
      container.style.transform = `translateX(${scrollPosition}px)`;
    });
    
    // 슬라이드 끝까지 도달하면 버튼을 추가해서 무한루프 시킬거임
    const buttons = Array.from(buttonContainer.children);
    buttons.forEach(btn => buttonContainer.appendChild(btn.cloneNode(true)));

    const slider = document.querySelector('.slide-container');
    const track = document.querySelector('.slider-wrapper');
    let scrollSpeed = 0.5; // 픽셀 나누기 프레임 단위
    let isPaused = false; // 호버를 하기전에는 계속 동작시킬것임
	
    // animate함수를 통해 슬라이드를 자동으로 부드럽게 동작시킴
    function animate() {
      if (!isPaused) {
        track.scrollLeft += scrollSpeed;
        // 끝에 도달하면 처음으로 돌아가기
        if (track.scrollLeft >= track.scrollWidth - track.clientWidth) {
          track.scrollLeft = 0;
        }
      }
      requestAnimationFrame(animate);
    }

    slider.addEventListener('mouseenter', () => isPaused = true);
    slider.addEventListener('mouseleave', () => isPaused = false);

    animate();
  </script>
</body>
</html>
